<!--Polymer Imports-->
<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/paper-slider/paper-slider.html">
<link rel="import" href="../bower_components/iron-icons/iron-icons.html">
<link rel="import" href="../bower_components/iron-icons/av-icons.html">
<link rel="import" href="../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../bower_components/iron-collapse/iron-collapse.html">
<!--1m2M Imports-->
<link rel="import" href="ONEm2M-graph.html">

<dom-module id="ONEm2M-audio-pulse-monitor">
  <template>
    <style>
      section {
        max-height: 300px;
      }
      .graph-container {
          display: inline-block;
          margin: 0.1em;        
          padding: 0.75em;
          border-radius: 1em;        
          background-color: lightgray;
          max-height: 240px;        
      }
      .controls {
        margin-bottom: 4px;
      }
      label {
        display: inline-block;        
        padding-bottom: 4px;
      }
      paper-slider {
        vertical-align: bottom;
        display: inline-block;
        margin-right: 1.5em;     
      }
      paper-icon-button {
        float: right;
      }      
    </style>    
    <section id="visualizations">      
      <div class="graph-container">        
        <div class="controls">
          <label>Pulse Threshold:</label>
          <paper-slider id="thresholdSlider" min="2500" max="7500" value="{{threshold}}"></paper-slider>
          <label>Pulse Count:</label>
          <span id="pulseCounter"></span>          
          <paper-icon-button on-tap="exportAudioData" icon="file-download"></paper-icon-button>
          <paper-icon-button on-tap="captureAudio" icon="av:fiber-manual-record"></paper-icon-button>
        </div>
        <iron-collapse id="graphDrawer">
          <ONEm2M-graph id="graph1"></ONEm2M-graph>
        <iron-collapse>
      </div>      
    </section>    
  </template>

  <script>
    Polymer({
      is: 'ONEm2M-audio-pulse-monitor',

      properties: {
        audioCtx: {
          type: Object
        },        
        isRecording: {
          type: Boolean,
          notify: true,
          reflectToAttribute: true
        },
        threshold: {
          type: Number,
          notify: true,
          reflectToAttribute: true,
          value: 5000,          
          observer: "_thresholdChanged"
        }        
      },      
      
      //_private functions
      _thresholdChanged: function(val) {
        console.log(val); //may need to use this to signal updating of metronome volume
      },

      //public functions
      captureAudio: function() {        
        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();        
        var analyser = this.audioCtx.createAnalyser();
        analyser.minDecibels = -90;
        analyser.maxDecibels = -10;
        analyser.smoothingTimeConstant = 0.85;
        
        let graphDrawer = this.$.graphDrawer;
        let graph = this.$.graph1;
        var canvasContext = this.$.graph1.context;

        var pulseCounter = this.$.pulseCounter;
        var pulseCount = 0;

        var drawVisual;

        function visualize(track) {
          analyser.fftSize = 256;
          var bufferLength = analyser.frequencyBinCount;
          console.log(bufferLength);
          var dataArray = new Uint8Array(bufferLength);          

          let x = graph.centerX; //100; // this.$.graph1.centerX;
          let barWidth = 1;
          let cumulationPeriod = 6;
          let volumePeriodLength = 0;
          let cumulativeVolume = 0;
          let volumeHistory = [];
          graphDrawer.toggle();
          function draw() {            
            if ((new Date().getTime() - startTime) <= 10000) {
              drawVisual = requestAnimationFrame(draw);
            }
            else
            {
              track.stop();
              sessionStorage.setItem("volumeHistory", volumeHistory);
              self.isRecording = false;
              graphDrawer.toggle();
            }
            analyser.getByteFrequencyData(dataArray);
            volumePeriodLength++;
            cumulativeVolume += getVolume(dataArray);
            if (volumePeriodLength == cumulationPeriod) {
              let volume = cumulativeVolume / cumulationPeriod / 20;
              if (pulseDetected(dataArray) && volume > 1000) {
                pulseCount++;
                pulseCounter.innerHTML = pulseCount + " : " + volume;
              }
              canvasContext.fillStyle = 'firebrick';
              canvasContext.fillRect(x,graph.centerY - volume / 2,barWidth,volume / 2);
              canvasContext.fillStyle = 'rgba(255,0,0, 0.5)';
              canvasContext.fillRect(x,graph.centerY,barWidth,volume / 2);
              volumeHistory.push(volume);
              x += barWidth;
              volumePeriodLength = 0;
              cumulativeVolume = 0;
            }
            //add beat markers for the metronome
            if (x % 10 == 0) {
              graph.drawVerticalLine(x);
            }
          };
          let startTime = new Date().getTime();
          self.isRecording = true;
          draw();
        }

        function getVolume(amplitudeData) {
          var volume = 0;
          for (var i = 0; i < amplitudeData.length; i++) {
             volume += amplitudeData[i];
          }
          //volume = Math.min(...amplitudeData.filter(Boolean));
          return volume;
        }

        var priorVolume = 0;
        var volumeIncrement = 0;
        var priorVolumeDirection;
        var inStrum = false;
        /*TAG:
        * Look for a jump of at least x (start with x=50), count that as the strum
        * then wait until you see consistent decreases before resetting to look for next jump/strum
        */
        function pulseDetected(amplitudeData) {
          var inflectionFound = false;
          var currentVolume = getVolume(amplitudeData);          
          volumeIncrement = currentVolume - priorVolume;
          priorVolume = currentVolume;
          if (volumeIncrement > 50) {
            if (!inStrum) {
              inStrum = true;
              inflectionFound = true;
            }
          } else if (volumeIncrement < 0) {
            inStrum = false;
          }
          return inflectionFound;
        }

        let self = this;
        navigator.mediaDevices.getUserMedia({audio: true}).then(function(mediaStream) {
          console.log("streamId: " + mediaStream.id);
          console.log("audioTrackId: " + mediaStream.getAudioTracks()[0].id);
          let track = mediaStream.getAudioTracks()[0];
          let source = self.audioCtx.createMediaStreamSource(mediaStream);
          source.connect(analyser);                      
          visualize(track);
        }).catch(function(err) {
          console.log(err);            
        });        
      },
      exportAudioData: function() {
        let element = document.createElement('a');
        element.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(sessionStorage.getItem("volumeHistory")));
        element.setAttribute("download", "audioHistory.csv");
        element.style.display = "none";
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
      }
    });
  </script>
</dom-module>