<!--Polymer Imports-->
<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/paper-slider/paper-slider.html">
<!--1m2M Imports-->
<link rel="import" href="ONEm2M-graph.html">

<dom-module id="ONEm2M-audio-pulse-monitor">
  <template>
    <style>
      section {
        height: 500px;
      }
      .visualizer-container {
        margin: 1em;        
        padding: 1em;
        border-radius: 1em;        
        background-color: lightgray;
        height: 20%;        
      }
      .visualizer {        
        background-color: white;
      }
    </style>
    <paper-slider min="2500" max="7500" value="{{threshold}}"></paper-slider>
    <button on-tap="captureAudio">Get Audio</button>
    </br>
    <section id="visualizations">
      <div id="visualizerContainer" class="visualizer-container">
        <canvas id="visualizer" class="visualizer"></canvas>
      </div>
      <ONEm2M-graph id="graph1"></ONEm2M-graph>
    </section>
    <p id="pulseCounter"></p>    
  </template>

  <script>
    Polymer({
      is: 'ONEm2M-audio-pulse-monitor',

      properties: {
        isRecording: {
          type: Boolean
        },
        threshold: {
          type: Number,
          notify: true,
          reflectToAttribute: true,
          value: 5000,          
          observer: "_thresholdChanged"
        },
        audioCtx: {
          type: Object
        }
      },

      attached: function() {
        let graph = this.$.visualizer;
        graph.width = 640;
        graph.height = 100;        
      },

      _thresholdChanged: function(val) {
        console.log(val); //may need to use this to signal updating of metronome volume
      },

      captureAudio: function() {
        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();        
        var analyser = this.audioCtx.createAnalyser();
        analyser.minDecibels = -90;
        analyser.maxDecibels = -10;
        analyser.smoothingTimeConstant = 0.85;

        //let canvasContainer = this.$.visualizerContainer;
        var canvas = this.$.visualizer;
        let graph = this.$.graph1;
        var canvasContext = this.$.graph1.context; //canvas.getContext("2d");
        //canvasContext.scale(1,1);

        var pulseCounter = this.$.pulseCounter;
        var pulseCount = 0;

        var drawVisual;

        function visualize(track) {
          WIDTH = canvas.width;
          HEIGHT = canvas.height;

          analyser.fftSize = 256;
          var bufferLength = analyser.frequencyBinCount;
          console.log(bufferLength);
          var dataArray = new Uint8Array(bufferLength);

          //canvasContext.clearRect(0, 0, WIDTH, HEIGHT);

          let x = graph.centerX; //100; // this.$.graph1.centerX;
          let barWidth = 1;
          let cumulationPeriod = 6;
          let volumePeriodLength = 0;
          let cumulativeVolume = 0;
          let volumeHistory = [];
          function draw() {            
            if ((new Date().getTime() - startTime) <= 10000) {
              drawVisual = requestAnimationFrame(draw);
            }
            else
            {
              console.log(analyser);
              track.stop();
            }
            analyser.getByteFrequencyData(dataArray);
            volumePeriodLength++;
            cumulativeVolume += getVolume(dataArray);
            if (volumePeriodLength == cumulationPeriod) {
              let volume = cumulativeVolume / cumulationPeriod / 20;
              if (pulseDetected(dataArray) && volume > 1000) {
                pulseCount++;
                pulseCounter.innerHTML = pulseCount + " : " + volume;
              }
              canvasContext.fillStyle = 'firebrick';
              canvasContext.fillRect(x,graph.centerY - volume / 2,barWidth,volume / 2);
              canvasContext.fillStyle = 'rgba(255,0,0, 0.5)';
              canvasContext.fillRect(x,graph.centerY,barWidth,volume / 2);
              volumeHistory.push(volume);
              x += barWidth;
              volumePeriodLength = 0;
              cumulativeVolume = 0;
            }
            //add beat markers for the metronome
            if (x % 10 == 0) {
              console.log("drawing vertical");
              graph.drawVerticalLine(x);
            }
          };
          let startTime = new Date().getTime();
          draw();
        }

        function getVolume(amplitudeData) {
          var volume = 0;
          for (var i = 0; i < amplitudeData.length; i++) {
             volume += amplitudeData[i];
          }
          //volume = Math.min(...amplitudeData.filter(Boolean));
          return volume;
        }

        var priorVolume = 0;
        var volumeIncrement = 0;
        var priorVolumeDirection;
        var inStrum = false;
        /*TAG:
        * Look for a jump of at least x (start with x=50), count that as the strum
        * then wait until you see consistent decreases before resetting to look for next jump/strum
        */
        function pulseDetected(amplitudeData) {
          var inflectionFound = false;
          var currentVolume = getVolume(amplitudeData);          
          volumeIncrement = currentVolume - priorVolume;
          priorVolume = currentVolume;
          if (volumeIncrement > 50) {
            if (!inStrum) {
              inStrum = true;
              inflectionFound = true;
            }
          } else if (volumeIncrement < 0) {
            inStrum = false;
          }
          return inflectionFound;
        }

        let self = this;
        navigator.mediaDevices.getUserMedia({audio: true}).then(function(mediaStream) {
          console.log("streamId: " + mediaStream.id);
          console.log("audioTrackId: " + mediaStream.getAudioTracks()[0].id);
          let track = mediaStream.getAudioTracks()[0];
          let source = self.audioCtx.createMediaStreamSource(mediaStream);
          source.connect(analyser);                      
          visualize(track);
        }).catch(function(err) {
          console.log(err);            
        });        
      }
    });
  </script>
</dom-module>